alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

alias sysCallNo S1;
sysCallNo = [physicalSP - 1];

if(sysCallNo == 8) then
    alias pcbIndex S2;
    pcbIndex = 0;
    while(pcbIndex < 32 && [READY_LIST + 32 * pcbIndex + 1] != 0) do
        pcbIndex = pcbIndex + 1;
    endwhile;

    print pcbIndex;
    if(pcbIndex >= 32) then
        [physicalSP - 2] = -1;
        ireturn;
    endif;

    [READY_LIST + pcbIndex * 32 + 0] = pcbIndex;

    alias valid_pages S3;
    alias counter S4;
    valid_pages = 0;
    counter = 1;
    while(counter < 8) do
        if([PTBR + counter] == "01" || [PTBR + counter] == "11") then
            valid_pages = valid_pages + 1;
        endif;
        counter = counter + 2;
    endwhile;

    alias mem_pages S5;
    mem_pages = 0;
    counter = 0;

    while(counter < 64) do
        if([MEM_LIST + counter] == 0) then
            mem_pages = mem_pages + 1;
        endif;
        counter = counter + 1;
    endwhile;

    if(mem_pages < valid_pages) then
        print "Memory Full";
        [physicalSP - 2] = -1;
        ireturn;
    endif;

    alias childPTBR S7;
    alias parentPTBR S8;

    childPTBR = PAGE_TABLE + pcbIndex * 8;
    parentPTBR = PTBR;

    alias counter2 S9;
    alias i S10;

    counter2 = 0;
    counter = 25;

    while(counter2 < 8) do
        if([MEM_LIST + counter] == 0) then
            if([PTBR + counter2 + 1] == "01" || [PTBR + counter2 + 1] == "11") then
                [MEM_LIST + counter] = 1;
                [childPTBR + counter2 + 1] = [PTBR + counter2 + 1];
                [childPTBR + counter2] = counter;

                i = 0;
                while(i < 512) do
                    [[childPTBR + counter2] * 512 + i] = [[parentPTBR + counter2] * 512 + i];
                    i = i + 1;
                endwhile;

                counter = counter + 1;
                counter2 = counter2 + 2;
            else
                counter2 = counter2 + 2;
            endif;
        else
            counter = counter + 1;
        endif;
    endwhile;

    [READY_LIST + pcbIndex * 32 + 1] = 1;
    [READY_LIST + pcbIndex * 32 + 2] = BP;
    [READY_LIST + pcbIndex * 32 + 3] = SP - 1;
    [READY_LIST + pcbIndex * 32 + 4] = [physicalSP];
    [READY_LIST + pcbIndex * 32 + 5] = childPTBR;
    [READY_LIST + pcbIndex * 32 + 6] = 4;

    [READY_LIST + pcbIndex * 32 + 7] = R0;
    [READY_LIST + pcbIndex * 32 + 8] = R1;
    [READY_LIST + pcbIndex * 32 + 9] = R2;
    [READY_LIST + pcbIndex * 32 + 10] = R3;
    [READY_LIST + pcbIndex * 32 + 11] = R4;
    [READY_LIST + pcbIndex * 32 + 12] = R5;
    [READY_LIST + pcbIndex * 32 + 13] = R6;
    [READY_LIST + pcbIndex * 32 + 14] = R7;

    counter = 15;
    while(counter < 31) do
        [READY_LIST + pcbIndex * 32 + counter] = [READY_LIST + ((PTBR - 1024) * 32) / 8 + counter];
        [READY_LIST + pcbIndex * 32 + counter + 1] = [READY_LIST + ((PTBR - 1024) * 32) / 8 + counter + 1];

        if([READY_LIST + ((PTBR - 1024) * 32) / 8 + counter] != -1) then
            [FILE_TABLE + [READY_LIST + ((PTBR - 1024) * 32) / 8 + counter] * 2 + 1] = [FILE_TABLE + [READY_LIST + ((PTBR - 1024) * 32) / 8 + counter] * 2 + 1] + 1;
        endif;
        counter = counter + 2;
    endwhile;

    [READY_LIST + pcbIndex * 32 + 31] = ((PTBR - 1024) / 8);

    [physicalSP - 2] = pcbIndex;

    alias childPhysicalSP S10;

    childPhysicalSP = [childPTBR + 2 * (SP - 1) / 512] * 512 + (SP - 1) % 512;

    [childPhysicalSP - 1] = -2;
    ireturn;
endif;
